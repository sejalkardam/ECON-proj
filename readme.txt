Assignment - 4
Sejal Kardam
2020467


The goal of the assignmnet is to create a kernel driven producer and consumer. To solve this problem, we created two different system call, that are reader() and writer(). Using the writer() system call, we enqueue data in queue and using the reader() system call, we dequeue data from the queue. We also need to ensure that both processes are not happening simultaneously or data is being enqueued in a full queue or data is being extracted from an empty queue. We used binary and counting semaphores to implement this. When queue is being accessed, the semaphore's value is zero which does not allow another process to enter the queue. After the process is done, its value is changed to one to ensure other processes can access it. Hence, this helps us resolve the first challenge. Then, we use counting semaphores, if_empty and if_full and set their respectives values as eight and zero. When we enqueue in the queue, we decrease the is_empty. If it becomes zero, it waits for the queue to be dequeued to ensure queue can not be overfilled. Similarly, while dequeuing, if_full is increased. In the same manner, we can not dequeue an empty queue. We then use make -j8 to compile the kernel.
We have created two patch files. sys_patch compares sys.c from the stock kernel and from the modifications we have made; and kernel_patch compares the difference between the entire kernel. (It is a large file) Also, we have added the two system calls in the syscall table in arch/x86/entry/syscalls. (this is not reflected in our patch file)  